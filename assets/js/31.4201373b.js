(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{424:function(e,s,a){"use strict";a.r(s);var t=a(5),v=Object(t.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"小程序语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小程序语法"}},[e._v("#")]),e._v(" 小程序语法")]),e._v(" "),s("p",[e._v("(ttml + js + ttss)")]),e._v(" "),s("p",[e._v("小程序作为一个有特殊业务属性的产物，对安全稳定体验有比较高的要求，所以它的方向是 webview + hybrid。具有 web 灵活开发，同时也能使用很多 app 提供的能力")]),e._v(" "),s("p",[e._v("因为安全的原由，小程序的开发和传统的 web 区别较大。最集中体现在对环境的操作，如 dom eval 这类。")]),e._v(" "),s("p",[e._v("小程序有一套 vue-like 的语法。如此选择一是因为它需要用模版来做一些控制隔离，而是做一些编译上的处理和优化。所以它摈弃了 react jsx 这种非常灵活的函数写法。而是结合 vue 和 svelte 的优点来做架构，他的 diff 也是结合这两个来做，不完全用 svelte 是因为想保持小体积。")]),e._v(" "),s("h2",{attrs:{id:"小程序架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小程序架构"}},[e._v("#")]),e._v(" 小程序架构")]),e._v(" "),s("p",[e._v("双线程。做到 js （v8,qjs,jsc）逻辑和实际 ui 渲染的分离，本质在于这是一个 app 上的 webview\n基于 app， 多 webview，web 标准")]),e._v(" "),s("h2",{attrs:{id:"小程序-js-选型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小程序-js-选型"}},[e._v("#")]),e._v(" 小程序 js 选型")]),e._v(" "),s("p",[e._v("这一块有很多选择")]),e._v(" "),s("p",[e._v("JavasScriptCore 是 ios 阵营，safari，wkwebview 自带。但是对安卓适配和性能差一些")]),e._v(" "),s("p",[e._v("V8 安卓阵营，性能很强，但是内存体积占用很高")]),e._v(" "),s("p",[e._v("Hermes facebook 为 react native 打造，体积小，内存小，适合重 ui 场景， hybrid 模式。（生成字节码。和端，多语言配合好）")]),e._v(" "),s("p",[e._v("QuickJs 内存体积很小，性能还可以。嵌入式开发友好")]),e._v(" "),s("p",[e._v("一般来说，ios 都会选择 jsc，安卓使用 qjs 的比较多")]),e._v(" "),s("h2",{attrs:{id:"jsbridge"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jsbridge"}},[e._v("#")]),e._v(" jsBridge")]),e._v(" "),s("p",[e._v("它更像是一个概念，有非常多种的实现。")]),e._v(" "),s("p",[e._v("比如可以直接粗暴的给 webview context 全局环境注入方法，使 js 可以直接用")]),e._v(" "),s("p",[e._v("也可以通过 uri scheme")]),e._v(" "),s("p",[e._v("这一块本质上来说，是构造了一个中间层 jssdk，将 app 的方法注入")]),e._v(" "),s("h2",{attrs:{id:"canvas-v2-v1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#canvas-v2-v1"}},[e._v("#")]),e._v(" canvas v2 v1")]),e._v(" "),s("p",[e._v("https://developers.weixin.qq.com/miniprogram/dev/framework/ability/canvas-legacy-migration.html")]),e._v(" "),s("p",[e._v("canvas v2 v1 的本质区别应该在于 canvas 这个组件从 webview 实现变成了端实现（同层渲染）")]),e._v(" "),s("p",[e._v("所以通信从 jscore => webview 变成了 jscore => end api")]),e._v(" "),s("p",[e._v("同时 js 通信从双线程变成了直接可以调端上同步方法，一些 canvas api 也转成了同步方法，也不再需要 draw 方法")]),e._v(" "),s("h3",{attrs:{id:"同层渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同层渲染"}},[e._v("#")]),e._v(" 同层渲染")]),e._v(" "),s("p",[e._v("解决一些高级功能不好用不可用，同步位置信息耗时，css 支持不好，zindex 不起作用，这类控件难受 webview 控制")]),e._v(" "),s("p",[e._v("最开始都是 cover 覆盖的方式叠层 webview，下面的 webview 对应的部分做透明，然后同步位置信息")]),e._v(" "),s("p",[e._v("ios =》WKWebview 启用 UIScrollVIew")]),e._v(" "),s("ol",[s("li",[e._v("background-color")]),e._v(" "),s("li",[e._v("className")])]),e._v(" "),s("p",[e._v("android 挖洞/三明治，本质多层\n1 找一块内容变透明下面放 background-webview native-view display-webview")]),e._v(" "),s("p",[e._v("真正同层")]),e._v(" "),s("ol",[s("li",[e._v("embed html")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('1. <embed style="width: 300px; height:200px;" type="plugon/text_box"> </embed>\n2. plugin receive => webview extension surfacetexture 绘制上屏\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("h2",{attrs:{id:"小程序测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小程序测试"}},[e._v("#")]),e._v(" 小程序测试")]),e._v(" "),s("p",[e._v("采用 shoots 服务\nhttps://github.com/Tencent/QTAF\nhttps://appium.io/docs/en/2.0/\nhttps://github.com/AirtestProject/Airtest")]),e._v(" "),s("p",[e._v("Accessibility")]),e._v(" "),s("h2",{attrs:{id:"其他参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其他参考"}},[e._v("#")]),e._v(" 其他参考")]),e._v(" "),s("h3",{attrs:{id:"react"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[e._v("#")]),e._v(" react")]),e._v(" "),s("p",[e._v("react 由于灵活的特性无法做预编译去进行标记，所以其 vdom 更新 只能从 root 开始重新生成,在大应用程序的场景下会非常卡。于是进行了时间分片的优化，设计了新的 fiber 和 schedule 来帮助做这件事情。实现了自己的 "),s("code",[e._v("requestIdleCallback")]),e._v("，同时也做了批量跟新来减少 update，其策略主要在运行时")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("render(){\n  return  <h1 class=\"greeting\">hello</h1>\n  return  react.createElement(\n    'h1',\n    { className: 'greeting' },\n    'Hello'\n  );  \n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[e._v("react is transformed from reactive to schedule")]),e._v(" "),s("ol",[s("li",[e._v("批量更新")]),e._v(" "),s("li",[e._v("并发")]),e._v(" "),s("li",[e._v("任务优先级(fetch data vs click)")])]),e._v(" "),s("h3",{attrs:{id:"vue"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[e._v("#")]),e._v(" vue")]),e._v(" "),s("p",[e._v("vue 由于其有模版 html，所以比较易做预编译处理优化。")]),e._v(" "),s("p",[e._v("1.打平树结构\n2. 提取静态标签\n3. 区分不同功能 "),s("code",[e._v("v-if v-for "+e._s(e.data))]),e._v("的标签进行不同处理")]),e._v(" "),s("h3",{attrs:{id:"svelte"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#svelte"}},[e._v("#")]),e._v(" svelte")]),e._v(" "),s("p",[e._v("svelte 则是不适用运行时，在编译时进行绑定")]),e._v(" "),s("h2",{attrs:{id:"附录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#附录"}},[e._v("#")]),e._v(" 附录")]),e._v(" "),s("p",[e._v("https://cloud.tencent.com/developer/article/1801742\nhttps://github.com/berwin/Blog/issues/49")])])}),[],!1,null,null,null);s.default=v.exports}}]);